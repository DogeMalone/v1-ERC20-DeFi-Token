"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileAnalyzer = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
const exportsAnalyzer_1 = require("./exportsAnalyzer");
const importsAnalyzer_1 = require("./importsAnalyzer");
const types_1 = require("./types");
class FileAnalyzer {
    /**
     * Filename to read to get contract data
     */
    constructor(filename, removeComments = true) {
        this.filename = filename;
        this.removeComments = removeComments;
    }
    /**
     * Builds the function body depending on the export
     */
    static buildExportBody(analyzedFile, e, newName, globalRenames) {
        if (e.type === types_1.ExportType.comment) {
            return e.body;
        }
        let is = e.is;
        if (is) {
            globalRenames.forEach((i) => {
                is = is.replace(`${i.globalRename}.${i.name}`, `${i.globalRename}$${i.name}`);
            });
            analyzedFile.imports.forEach((i) => {
                if (i.namedImports) {
                    i.namedImports.forEach((ni) => {
                        if (ni.as) {
                            is = is.replace(ni.name, ni.as);
                        }
                    });
                }
            });
        }
        const abstract = e.abstact ? 'abstract ' : '';
        return `${abstract}${e.type} ${newName || e.name} ${is}${e.body}`;
    }
    /**
     * Returns imports and exports of the processing file
     */
    analyze() {
        return __awaiter(this, void 0, void 0, function* () {
            yield fs_extra_1.default.stat(this.filename);
            let contents = yield fs_extra_1.default.readFile(this.filename, { encoding: 'utf-8' });
            if (this.removeComments) {
                contents = strip_json_comments_1.default(contents, { whitespace: false });
            }
            const importsAnalyzer = new importsAnalyzer_1.ImportsAnalyzer(contents);
            const imports = importsAnalyzer.analyzeImports();
            const exportsAnalyzer = new exportsAnalyzer_1.ExportsAnalyzer(contents);
            const exports = exportsAnalyzer.analyzeExports();
            return {
                filename: this.filename,
                contents,
                imports,
                exports,
            };
        });
    }
}
exports.FileAnalyzer = FileAnalyzer;
//# sourceMappingURL=fileAnalyzer.js.map