"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _inputContent, _antlrTree, _comments, _onVisit;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolidityExportVisitor = void 0;
const antlr4ts_1 = require("antlr4ts");
const ParseTreeWalker_1 = require("antlr4ts/tree/ParseTreeWalker");
const types_1 = require("../../types");
const SolidityLexer_1 = require("../generated/SolidityLexer");
const SolidityParser_1 = require("../generated/SolidityParser");
const HIDDEN_CHANNEL = 1;
class SolidityExportVisitor {
    constructor(inputContent) {
        _inputContent.set(this, void 0);
        _antlrTree.set(this, void 0);
        _comments.set(this, []);
        __classPrivateFieldSet(this, _inputContent, inputContent);
        const chars = antlr4ts_1.CharStreams.fromString(__classPrivateFieldGet(this, _inputContent));
        const lexer = new SolidityLexer_1.SolidityLexer(chars);
        const tokens = new antlr4ts_1.CommonTokenStream(lexer);
        const parser = new SolidityParser_1.SolidityParser(tokens);
        __classPrivateFieldSet(this, _antlrTree, parser.sourceUnit());
        __classPrivateFieldSet(this, _comments, tokens
            .getRange(0, tokens.size)
            .filter((t) => t.channel === HIDDEN_CHANNEL));
    }
    visit(onVisit) {
        const listener = new ExportVisitor((visitResult) => {
            this.onVisit(visitResult, onVisit);
        });
        ParseTreeWalker_1.ParseTreeWalker.DEFAULT.walk(listener, __classPrivateFieldGet(this, _antlrTree));
        this.flushComments(onVisit);
    }
    onVisit(visitResult, onVisit) {
        if (!__classPrivateFieldGet(this, _comments).length) {
            return onVisit(visitResult);
        }
        this.emitCommentsBefore(visitResult, onVisit);
        onVisit(visitResult);
    }
    emitCommentsBefore(visitResult, onVisit) {
        while (__classPrivateFieldGet(this, _comments).length &&
            __classPrivateFieldGet(this, _comments)[0].startIndex < visitResult.start) {
            const comment = __classPrivateFieldGet(this, _comments).shift();
            if (!comment) {
                continue;
            }
            onVisit(this.buildComment(comment));
        }
        while (__classPrivateFieldGet(this, _comments).length &&
            __classPrivateFieldGet(this, _comments)[0].stopIndex < visitResult.end) {
            __classPrivateFieldGet(this, _comments).shift();
        }
    }
    flushComments(onVisit) {
        if (!__classPrivateFieldGet(this, _comments).length) {
            return;
        }
        __classPrivateFieldGet(this, _comments).forEach((comment) => onVisit(this.buildComment(comment)));
    }
    buildComment(comment) {
        return {
            abstract: false,
            body: {
                start: comment.startIndex,
                end: comment.stopIndex,
            },
            start: comment.startIndex,
            end: comment.stopIndex,
            is: null,
            name: `Comment#${comment.startIndex}`,
            type: types_1.ExportType.comment,
        };
    }
}
exports.SolidityExportVisitor = SolidityExportVisitor;
_inputContent = new WeakMap(), _antlrTree = new WeakMap(), _comments = new WeakMap();
class ExportVisitor {
    constructor(onVisit) {
        _onVisit.set(this, void 0);
        __classPrivateFieldSet(this, _onVisit, onVisit);
    }
    enterContractDefinition(ctx) {
        var _a, _b, _c, _d;
        if (!ctx.stop) {
            return;
        }
        if (!ctx.children) {
            return;
        }
        const start = ctx.start.startIndex;
        const end = ctx.stop.stopIndex;
        const abstract = ctx.children[0].text === 'abstract';
        const type = abstract
            ? ctx.children[1].text
            : ctx.children[0].text;
        const name = ctx.identifier();
        const inheritance = ctx.getRuleContexts(SolidityParser_1.InheritanceSpecifierContext);
        const bodyStart = inheritance.length
            ? (_a = inheritance[inheritance.length - 1].stop) === null || _a === void 0 ? void 0 : _a.stopIndex : (_b = name.stop) === null || _b === void 0 ? void 0 : _b.stopIndex;
        const isStart = inheritance.length ? (_c = name.stop) === null || _c === void 0 ? void 0 : _c.stopIndex : null;
        const isEnd = inheritance.length
            ? (_d = inheritance[inheritance.length - 1].stop) === null || _d === void 0 ? void 0 : _d.stopIndex : null;
        const is = isStart && isEnd ? { start: isStart + 1, end: isEnd + 1 } : null;
        if (!bodyStart) {
            return;
        }
        __classPrivateFieldGet(this, _onVisit).call(this, {
            start,
            end,
            abstract,
            type,
            body: {
                start: bodyStart + 1,
                end,
            },
            is: is,
            name: name.text,
        });
    }
    enterStructDefinition(ctx) {
        if (!(ctx.parent instanceof SolidityParser_1.SourceUnitContext)) {
            return;
        }
        if (!ctx.stop) {
            return;
        }
        if (!ctx.children) {
            return;
        }
        const start = ctx.start.startIndex;
        const end = ctx.stop.stopIndex;
        const name = ctx.identifier();
        if (!name.stop) {
            return;
        }
        const bodyStart = name.stop.stopIndex;
        __classPrivateFieldGet(this, _onVisit).call(this, {
            start,
            end,
            abstract: false,
            type: types_1.ExportType.struct,
            body: {
                start: bodyStart + 1,
                end,
            },
            is: null,
            name: name.text,
        });
    }
    enterEnumDefinition(ctx) {
        if (!(ctx.parent instanceof SolidityParser_1.SourceUnitContext)) {
            return;
        }
        if (!ctx.stop) {
            return;
        }
        if (!ctx.children) {
            return;
        }
        const start = ctx.start.startIndex;
        const end = ctx.stop.stopIndex;
        const name = ctx.identifier();
        if (!name.stop) {
            return;
        }
        const bodyStart = name.stop.stopIndex;
        __classPrivateFieldGet(this, _onVisit).call(this, {
            start,
            end,
            abstract: false,
            type: types_1.ExportType.enum,
            body: {
                start: bodyStart + 1,
                end,
            },
            is: null,
            name: name.text,
        });
    }
}
_onVisit = new WeakMap();
//# sourceMappingURL=exportVisitor.js.map